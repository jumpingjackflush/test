<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>簡易・山手線 クリック塗りアプリ</title>
  <style>
    body { font-family: system-ui, sans-serif; display: grid; place-items: center; gap: 10px; margin: 20px; }
    #toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    #map { border: 1px solid #bbb; background:#f8f8f8; cursor: pointer; border-radius: 8px; }
    .stat { font-size: 14px; color: #333; }
    button { padding: 6px 12px; border: 1px solid #aaa; border-radius: 6px; background: #fff; }
    button:hover { background:#f0f0f0; }
  </style>
</head>
<body>
  <h1>簡易・山手線（クリックで区間を塗る）</h1>

  <div id="toolbar">
    <button id="saveBtn">保存</button>
    <button id="loadBtn">読込</button>
    <button id="clearBtn">全解除</button>
    <span class="stat">塗った区間: <span id="count">0</span> / <span id="total">0</span></span>
  </div>

  <canvas id="map" width="800" height="800"></canvas>

  <script>
    // ====== 山手線 駅名（時計回り）======
    // 30駅（2020年開業の 高輪ゲートウェイ を含む）
    const stationNames = [
      "東京","有楽町","新橋","浜松町","田町","高輪ゲートウェイ","品川","大崎","五反田","目黒",
      "恵比寿","渋谷","原宿","代々木","新宿","新大久保","高田馬場","目白","池袋","大塚",
      "巣鴨","駒込","田端","西日暮里","日暮里","鶯谷","上野","御徒町","秋葉原","神田"
    ];

    // ====== レイアウト（円形配置）======
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;
    const cx = W/2, cy = H/2;           // 中心
    const R  = 290;                      // 線の半径
    const labelR = R + 22;               // 駅名の半径（少し外側）
    const N = stationNames.length;

    // 極座標→XY
    function polar(angleRad, radius) {
      return { x: cx + radius * Math.cos(angleRad), y: cy + radius * Math.sin(angleRad) };
    }

    // 駅座標（時計回りに均等配置／上=0°ではなく右=0°なので、-90°から開始して上を0に揃える）
    const stations = [];
    for (let i = 0; i < N; i++) {
      const theta = (-Math.PI/2) + i * (2*Math.PI/N);
      const p = polar(theta, R);
      stations.push({ id:i, name: stationNames[i], x:p.x, y:p.y, angle: theta });
    }

    // 区間（隣接駅を結ぶ）：0-1,1-2,...,N-1→0
    const edges = [];
    for (let i = 0; i < N; i++) {
      const j = (i+1) % N;
      edges.push({ from:i, to:j, color: "green", active: false });
    }

    // ====== 描画 ======
    function draw() {
      ctx.clearRect(0,0,W,H);

      // 1) ガイド（薄い灰の円）
      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.strokeStyle = "#e0e0e0";
      ctx.lineWidth = 2;
      ctx.stroke();

      // 2) 区間（まず全区間をベース色で、activeは上から上書き）
      // ベース（未乗車：緑）
      edges.forEach(e => {
        const a = stations[e.from], b = stations[e.to];
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.lineWidth = 10;
        ctx.lineCap = "round";
        ctx.strokeStyle = e.active ? "#d33" : "#2e8b57"; // 赤 or 緑
        ctx.stroke();
      });

      // 3) 駅（丸）
      stations.forEach(s => {
        ctx.beginPath();
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.arc(s.x, s.y, 6, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      });

      // 4) 駅名（外周に沿って）
      ctx.font = "12px system-ui, sans-serif";
      ctx.fillStyle = "#111";
      ctx.textBaseline = "middle";
      stations.forEach(s => {
        const label = polar(s.angle, labelR);
        // テキストを読みやすく：左右で寄せ方向を変える
        const deg = ((s.angle*180/Math.PI)+360)%360;
        if (deg > 90 && deg < 270) {
          // 左半分：右寄せ
          ctx.textAlign = "right";
        } else {
          // 右半分：左寄せ
          ctx.textAlign = "left";
        }
        ctx.fillText(s.name, label.x, label.y);
      });

      // 5) 統計の更新
      document.getElementById("count").textContent = edges.filter(e=>e.active).length;
      document.getElementById("total").textContent = edges.length;
    }

    // ====== クリック判定（点と線分の距離）======
    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const vx = x2 - x1, vy = y2 - y1;
      const wx = px - x1, wy = py - y1;
      const c1 = vx*wx + vy*wy;
      if (c1 <= 0) return Math.hypot(px - x1, py - y1);
      const c2 = vx*vx + vy*vy;
      if (c2 <= c1) return Math.hypot(px - x2, py - y2);
      const t = c1 / c2;
      const projx = x1 + t*vx, projy = y1 + t*vy;
      return Math.hypot(px - projx, py - projy);
    }

    canvas.addEventListener("click", (ev) => {
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;

      // 一番近い区間を探す（しきい値以内）
      let bestEdge = null;
      let bestDist = Infinity;
      edges.forEach((e, idx) => {
        const a = stations[e.from], b = stations[e.to];
        const d = pointToSegmentDistance(x, y, a.x, a.y, b.x, b.y);
        if (d < bestDist) {
          bestDist = d;
          bestEdge = e;
        }
      });

      // しきい値（線の太さ+余裕）
      if (bestEdge && bestDist <= 12) {
        bestEdge.active = !bestEdge.active;
        draw();
      }
    });

    // ====== 保存/読込/全解除（localStorage）======
    const STORAGE_KEY = "yamanote_edges_state_v1";

    document.getElementById("saveBtn").onclick = () => {
      const state = edges.map(e => e.active ? 1 : 0);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      alert("保存しました。");
    };

    document.getElementById("loadBtn").onclick = () => {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) { alert("保存データがありません。"); return; }
      try {
        const state = JSON.parse(raw);
        edges.forEach((e, i) => { e.active = !!state[i]; });
        draw();
        alert("読込完了。");
      } catch {
        alert("保存データの読み込みに失敗しました。");
      }
    };

    document.getElementById("clearBtn").onclick = () => {
      edges.forEach(e => e.active = false);
      draw();
    };

    // 初回描画
    draw();
  </script>
</body>
</html>
