<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>山手線・中央線 クリック塗りアプリ (ズーム対応)</title>
  <style>
    body { font-family: system-ui, sans-serif; display: grid; place-items: center; gap: 10px; margin: 20px; }
    #toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    #map { 
      border: 1px solid #bbb; 
      background:#f8f8f8; 
      cursor: pointer; /* 通常時はポインター */
      border-radius: 8px; 
      user-select: none; /* テキスト選択を無効化 */
    }
    .stat { font-size: 14px; color: #333; }
    button { padding: 6px 12px; border: 1px solid #aaa; border-radius: 6px; background: #fff; }
    button:hover { background:#f0f0f0; }
  </style>
</head>
<body>
  <h1>簡易・山手線＆中央線（クリックで区間を塗る）</h1>

  <div id="toolbar">
    <button id="saveBtn">保存</button>
    <button id="loadBtn">読込</button>
    <button id="clearBtn">全解除</button>
    <button id="resetBtn">視点リセット</button> <span class="stat">塗った区間: <span id="count">0</span> / <span id="total">0</span></span>
  </div>

  <canvas id="map" width="800" height="800"></canvas>

  <script>
    // ====== 山手線 駅名（時計回り）======
    const yamanoteStationNames = [
      "田端","西日暮里","日暮里","鶯谷","上野","御徒町","秋葉原","神田","東京","有楽町",
      "新橋","浜松町","田町","高輪ゲートウェイ","品川","大崎","五反田","目黒",
      "恵比寿","渋谷","原宿","代々木","新宿","新大久保","高田馬場","目白","池袋","大塚",
      "巣鴨","駒込"
    ];

    // ====== レイアウト（円形配置）======
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;
    const cx = W/2, cy = H/2;
    const R  = 290;
    const labelR = R + 22;
    const N = yamanoteStationNames.length;

    // --- 視点（ズーム/パン）の状態 ---
    let scale = 1.0;
    let offsetX = 0.0;
    let offsetY = 0.0;
    let isDragging = false;
    let didDrag = false; // ドラッグ操作とクリックを区別するため
    let lastX = 0, lastY = 0;
    const MIN_SCALE = 0.3;
    const MAX_SCALE = 10.0;
    // ---

    // 極座標→XY
    function polar(angleRad, radius) {
      return { x: cx + radius * Math.cos(angleRad), y: cy + radius * Math.sin(angleRad) };
    }

    // --- データ構造 ---
    const stationCoords = new Map();
    for (let i = 0; i < N; i++) {
      const theta = (-Math.PI/2) + i * (2*Math.PI/N);
      const p = polar(theta, R);
      const station = { id:i, name: yamanoteStationNames[i], x:p.x, y:p.y, angle: theta };
      stationCoords.set(station.name, station);
    }
    const allStations = Array.from(stationCoords.values());

    const yamanoteEdges = [];
    for (let i = 0; i < N; i++) {
      const j = (i+1) % N;
      yamanoteEdges.push({ 
        from: i, to: j, active: false, color: "#2e8b57", activeColor: "#d33" 
      });
    }

    const chuoShinjuku = stationCoords.get("新宿");
    const chuoKanda = stationCoords.get("神田");
    const chuoTokyo = stationCoords.get("東京");

    const yotsuya = {
      id: N, name: "四ツ谷",
      x: chuoShinjuku.x + (chuoKanda.x - chuoShinjuku.x) / 3,
      y: chuoShinjuku.y + (chuoKanda.y - chuoShinjuku.y) / 3,
      angle: null
    };
    const ochanomizu = {
      id: N + 1, name: "御茶ノ水",
      x: chuoShinjuku.x + (chuoKanda.x - chuoShinjuku.x) * 2 / 3,
      y: chuoShinjuku.y + (chuoKanda.y - chuoShinjuku.y) * 2 / 3,
      angle: null
    };

    stationCoords.set(yotsuya.name, yotsuya);
    stationCoords.set(ochanomizu.name, ochanomizu);
    allStations.push(yotsuya, ochanomizu);

    const chuoColor = "#f07e00";
    const activeColor = "#d33";
    const chuoEdges = [
      { from: chuoShinjuku.id, to: yotsuya.id, active: false, color: chuoColor, activeColor: activeColor },
      { from: yotsuya.id, to: ochanomizu.id, active: false, color: chuoColor, activeColor: activeColor },
      { from: ochanomizu.id, to: chuoKanda.id, active: false, color: chuoColor, activeColor: activeColor },
      { from: chuoKanda.id, to: chuoTokyo.id, active: false, color: chuoColor, activeColor: activeColor }
    ];

    const allEdges = [...yamanoteEdges, ...chuoEdges];
    // --- データ構造ここまで ---


    // ====== 描画 (変更) ======
    function draw() {
      // 1. デフォルトの(変換されていない)状態を保存
      ctx.save();
      
      // 2. 画面基準でキャンバス全体をクリア
      ctx.clearRect(0,0,W,H);
      
      // 3. ズーム/パンを適用
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

      // --- 以下は元の描画処理 (座標系が変換されている) ---

      // 1) ガイド（薄い灰の円）
      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.strokeStyle = "#e0e0e0";
      ctx.lineWidth = 2;
      ctx.stroke();

      // 2) 区間（全路線を描画）
      allEdges.forEach(e => {
        const a = allStations[e.from], b = allStations[e.to];
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.lineWidth = 10;
        ctx.lineCap = "round";
        ctx.strokeStyle = e.active ? e.activeColor : e.color;
        ctx.stroke();
      });

      // 3) 駅（丸）
      allStations.forEach(s => {
        ctx.beginPath();
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.arc(s.x, s.y, 6, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      });

      // 4) 駅名
      ctx.font = "12px system-ui, sans-serif";
      ctx.fillStyle = "#111";
      ctx.textBaseline = "middle";
      
      allStations.forEach(s => {
        if (s.angle !== null) {
          const label = polar(s.angle, labelR);
          const deg = ((s.angle*180/Math.PI)+360)%360;
          if (deg > 90 && deg < 270) {
            ctx.textAlign = "right";
          } else {
            ctx.textAlign = "left";
          }
          ctx.fillText(s.name, label.x, label.y);
        } else {
          ctx.textAlign = "center";
          ctx.fillText(s.name, s.x, s.y - 15);
        }
      });
      // --- 元の描画処理ここまで ---

      // 5. 統計の更新 (これはDOM操作なので変換の影響を受けない)
      document.getElementById("count").textContent = allEdges.filter(e=>e.active).length;
      document.getElementById("total").textContent = allEdges.length;

      // 6. 座標系をデフォルトに戻す
      ctx.restore();
    }

    // ====== クリック判定（点と線分の距離）======
    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const vx = x2 - x1, vy = y2 - y1;
      const wx = px - x1, wy = py - y1;
      const c1 = vx*wx + vy*wy;
      if (c1 <= 0) return Math.hypot(px - x1, py - y1);
      const c2 = vx*vx + vy*vy;
      if (c2 <= c1) return Math.hypot(px - x2, py - y2);
      const t = c1 / c2;
      const projx = x1 + t*vx, projy = y1 + t*vy;
      return Math.hypot(px - projx, py - projy);
    }

    // ====== イベントハンドラ (変更) ======

    // 画面上の座標 (sx, sy) を ワールド座標 (wx, wy) に変換
    function screenToWorld(sx, sy) {
      return { x: (sx - offsetX) / scale, y: (sy - offsetY) / scale };
    }

    // クリック処理 (変更)
    canvas.addEventListener("click", (ev) => {
      // ドラッグ操作直後ならクリックとみなさない
      if (didDrag) {
        didDrag = false;
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const screenX = ev.clientX - rect.left;
      const screenY = ev.clientY - rect.top;

      // 画面座標をクリック座標に変換
      const world = screenToWorld(screenX, screenY);

      let bestEdge = null;
      let bestDist = Infinity;
      allEdges.forEach((e) => {
        const a = allStations[e.from], b = allStations[e.to];
        // ワールド座標で距離を計算
        const d = pointToSegmentDistance(world.x, world.y, a.x, a.y, b.x, b.y);
        if (d < bestDist) {
          bestDist = d;
          bestEdge = e;
        }
      });

      // しきい値もスケールを考慮
      // (ワールド座標での距離 * スケール = 画面上でのピクセル距離)
      if (bestEdge && (bestDist * scale) <= 12) {
        bestEdge.active = !bestEdge.active;
        draw();
      }
    });

    // --- ズーム/パン ハンドラ (ここから追加) ---

    // 1. ズーム (ホイール)
    canvas.addEventListener("wheel", (ev) => {
      ev.preventDefault(); // ページのスクロールを防ぐ

      const rect = canvas.getBoundingClientRect();
      const screenX = ev.clientX - rect.left;
      const screenY = ev.clientY - rect.top;

      // 1. マウス位置のワールド座標 (ズーム前)
      const worldBefore = screenToWorld(screenX, screenY);
      
      // 2. 新しいスケールを計算
      const zoomFactor = 1.1;
      let newScale = (ev.deltaY < 0) ? (scale * zoomFactor) : (scale / zoomFactor);
      newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale)); // 範囲制限

      // 3. マウス位置のワールド座標が、ズーム後も同じ画面座標に来るようにオフセットを計算
      // screenX = worldBefore.x * newScale + newOffsetX
      const newOffsetX = screenX - worldBefore.x * newScale;
      const newOffsetY = screenY - worldBefore.y * newScale;

      // 4. 状態を更新
      scale = newScale;
      offsetX = newOffsetX;
      offsetY = newOffsetY;

      draw();
    });

    // 2. パン (ドラッグ) - 開始
    canvas.addEventListener("mousedown", (ev) => {
      isDragging = true;
      didDrag = false; // ドラッグ開始時はリセット
      lastX = ev.clientX;
      lastY = ev.clientY;
      canvas.style.cursor = 'grabbing'; // カーソルを「掴む」に
    });

    // 3. パン (ドラッグ) - 移動中
    canvas.addEventListener("mousemove", (ev) => {
      if (!isDragging) return;
      ev.preventDefault();
      didDrag = true; // 少しでも動いたらドラッグとみなす

      const dx = ev.clientX - lastX;
      const dy = ev.clientY - lastY;

      offsetX += dx;
      offsetY += dy;

      lastX = ev.clientX;
      lastY = ev.clientY;

      draw();
    });

    // 4. パン (ドラッグ) - 終了
    canvas.addEventListener("mouseup", (ev) => {
      isDragging = false;
      canvas.style.cursor = 'pointer';
    });

    // 5. パン (ドラッグ) - キャンバス外に出た
    canvas.addEventListener("mouseleave", (ev) => {
      isDragging = false;
      canvas.style.cursor = 'pointer';
    });


    // ====== 保存/読込/全解除（localStorage）======
    const STORAGE_KEY = "yamanote_chuo_edges_state_v2"; 

    document.getElementById("saveBtn").onclick = () => {
      const state = allEdges.map(e => e.active ? 1 : 0);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      alert("保存しました。");
    };

    document.getElementById("loadBtn").onclick = () => {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) { alert("保存データがありません。"); return; }
      try {
        const state = JSON.parse(raw);
        if (state.length !== allEdges.length) {
          alert("データ形式が古いため読み込めません。");
          localStorage.removeItem(STORAGE_KEY);
          return;
        }
        allEdges.forEach((e, i) => { e.active = !!state[i]; });
        draw();
        alert("読込完了。");
      } catch {
        alert("保存データの読み込みに失敗しました。");
      }
    };

    document.getElementById("clearBtn").onclick = () => {
      allEdges.forEach(e => e.active = false);
      draw();
    };

    // 視点リセットボタン (追加)
    document.getElementById("resetBtn").onclick = () => {
      scale = 1.0;
      offsetX = 0.0;
      offsetY = 0.0;
      draw();
    };

    // 初回描画
    draw();
  </script>
</body>
</html>
