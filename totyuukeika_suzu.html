<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>山手線・中央線 クリック塗りアプリ (ズーム対応)</title>
  <style>
    body { font-family: system-ui, sans-serif; display: grid; place-items: center; gap: 10px; margin: 20px; }
    #toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    #map { 
      border: 1px solid #bbb; 
      background:#f8f8f8; 
      cursor: pointer;
      border-radius: 8px; 
      user-select: none;
    }
    .stat { font-size: 14px; color: #333; }
    button { padding: 6px 12px; border: 1px solid #aaa; border-radius: 6px; background: #fff; }
    button:hover { background:#f0f0f0; }
  </style>
</head>
<body>
  <h1>簡易・山手線＆中央線（クリックで区間を塗る）</h1>

  <div id="toolbar">
    <button id="saveBtn">保存</button>
    <button id="loadBtn">読込</button>
    <button id="clearBtn">全解除</button>
    <button id="resetBtn">視点リセット</button> <span class="stat">塗った区間: <span id="count">0</span> / <span id="total">0</span></span>
  </div>

  <canvas id="map" width="800" height="800"></canvas>

  <script>
    //  山手線駅名（時計回り）
    const yamanote = [
      "田端","西日暮里","日暮里","鶯谷","上野","御徒町","秋葉原","神田","東京","有楽町",
      "新橋","浜松町","田町","高輪ゲートウェイ","品川","大崎","五反田","目黒",
      "恵比寿","渋谷","原宿","代々木","新宿","新大久保","高田馬場","目白","池袋","大塚",
      "巣鴨","駒込"
    ];

    // 山手線を円形に配置
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;
    const cx = W/2, cy = H/2;
    const R  = 290;
    const labelR = R + 22;
    const N = yamanote.length;

    //  視点の状態 
    let scale = 1.0;
    let defaultX = 0.0;
    let defaultY = 0.0;
    let nowDrag = false;
    let didDrag = false; 
    let lastX = 0, lastY = 0;
    const MIN_SCALE = 0.3;
    const MAX_SCALE = 10.0;
    

    // xy座標に変換
    function polar(angle, radius) {
      return { x: cx + radius * Math.cos(angle), y: cy + radius * Math.sin(angle) };
    }

    // データ構造 
    const stationFigure = new Map();
    for (let i = 0; i < N; i++) {
      const theta = (-Math.PI/2) + i * (2*Math.PI/N);
      const p = polar(theta, R);
      const station = { id:i, name: yamanote[i], x:p.x, y:p.y, angle: theta };
      stationFigure.set(station.name, station);
    }
    const allStations = Array.from(stationFigure.values());

    const yamanoteEdges = [];
    for (let i = 0; i < N; i++) {
      const j = (i+1) % N;
      yamanoteEdges.push({ 
        from: i, to: j, active: false, color: "#808080", activeColor: "#d33" 
      });
    }

    const chuoShinjuku = stationFigure.get("新宿");
    const chuoKanda = stationFigure.get("神田");
    const chuoTokyo = stationFigure.get("東京");
    const yamatabata = stationFigure.get("田端");

    // 追加例（お試し）
    const yotsuya = {
      id: N, name: "四ツ谷",
      x: chuoShinjuku.x + (chuoKanda.x - chuoShinjuku.x) / 3,
      y: chuoShinjuku.y + (chuoKanda.y - chuoShinjuku.y) / 3,
      angle: null
    };
    const ochanomizu = {
      id: N + 1, name: "御茶ノ水",
      x: chuoShinjuku.x + (chuoKanda.x - chuoShinjuku.x) * 2 / 3,
      y: chuoShinjuku.y + (chuoKanda.y - chuoShinjuku.y) * 2 / 3,
      angle: null
    };

    stationFigure.set(yotsuya.name, yotsuya);
    stationFigure.set(ochanomizu.name, ochanomizu);
    allStations.push(yotsuya, ochanomizu);

    const defaultColor = "#808080";
    const activeColor = "#d33";
    const chuoEdges = [
      { from: chuoShinjuku.id, to: yotsuya.id, active: false, color: defaultColor, activeColor: activeColor },
      { from: yotsuya.id, to: ochanomizu.id, active: false, color: defaultColor, activeColor: activeColor },
      { from: ochanomizu.id, to: chuoKanda.id, active: false, color: defaultColor, activeColor: activeColor }
    ];

    // 新しい駅を追加するためのID
    let newId = allStations.length;

    // 新しい駅を追加するようの関数（現状, 中央線は適応外）
    function addStationsAndEdges(stationData) {
      const newEdges = [];

      for (const stationInfo of stationData) {
        // 始点の駅を取得
        const startStation = stationFigure.get(stationInfo.start);
        // 支店の駅がなかった場合次の駅へ
        if (!startStation) {
          console.error(`始点駅 "${stationInfo.start}" が見つかりません。`);
          continue; 
        }

        // 新しい駅を作成する用
        const newStation = {
          id: newId,
          name: stationInfo.name,
          x: startStation.x + stationInfo.dx,
          y: startStation.y + stationInfo.dy,
          angle: null,
        };

        // allStationsに新しい駅を追加
        allStations.push(newStation);
        stationFigure.set(newStation.name, newStation);

        // 新しい頂点を作成
        newEdges.push({
          from: startStation.id,
          to: newStation.id,
          active: false,
          color: defaultColor,
          activeColor: activeColor
        });

        // 次の駅のためにIDを+
        newId++;
      }
      return newEdges;
    }

    // 京浜東北線のデータ定義 (山手線, 中央線とは別物)
    const keihinStationData = [
      { start: "田端", name: "上中里", dx: -50, dy: -50 },
      { start: "上中里", name: "王子", dx: -50, dy: -50 },
      { start: "品川", name: "大井町", dx: -50, dy: 50 },
    ];

    // 京浜東北線の駅と頂点を生成
    const keihinEdges = addStationsAndEdges(keihinStationData);

    const allEdges = [...yamanoteEdges, ...chuoEdges, ...keihinEdges];
    


    // 描画
    function draw() {
      ctx.save();
      ctx.clearRect(0,0,W,H);
      ctx.setTransform(scale, 0, 0, scale, defaultX, defaultY);

      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.strokeStyle = "#e0e0e0";
      ctx.lineWidth = 2;
      ctx.stroke();

      allEdges.forEach(e => {
        const a = allStations[e.from], b = allStations[e.to];
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.lineWidth = 10;
        ctx.lineCap = "round";
        ctx.strokeStyle = e.active ? e.activeColor : e.color;
        ctx.stroke();
      });

      allStations.forEach(s => {
        ctx.beginPath();
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.arc(s.x, s.y, 6, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      });

      ctx.font = "12px system-ui, sans-serif";
      ctx.fillStyle = "#111";
      ctx.textBaseline = "middle";
      
      allStations.forEach(s => {
        if (s.angle !== null) {
          const label = polar(s.angle, labelR);
          const deg = ((s.angle*180/Math.PI)+360)%360;
          if (deg > 90 && deg < 270) {
            ctx.textAlign = "right";
          } else {
            ctx.textAlign = "left";
          }
          ctx.fillText(s.name, label.x, label.y);
        } else {
          ctx.textAlign = "center";
          ctx.fillText(s.name, s.x, s.y - 15);
        }
      });

      document.getElementById("count").textContent = allEdges.filter(e=>e.active).length;
      document.getElementById("total").textContent = allEdges.length;

      ctx.restore();
    }

    // クリック判定
    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const vx = x2 - x1, vy = y2 - y1;
      const wx = px - x1, wy = py - y1;
      const c1 = vx*wx + vy*wy;
      if (c1 <= 0) return Math.hypot(px - x1, py - y1);
      const c2 = vx*vx + vy*vy;
      if (c2 <= c1) return Math.hypot(px - x2, py - y2);
      const t = c1 / c2;
      const projx = x1 + t*vx, projy = y1 + t*vy;
      return Math.hypot(px - projx, py - projy);
    }

    // イベントハンドラ
    function screenToWorld(sx, sy) {
      return { x: (sx - defaultX) / scale, y: (sy - defaultY) / scale };
    }

    canvas.addEventListener("click", (ev) => {
      if (didDrag) {
        didDrag = false;
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const screenX = ev.clientX - rect.left;
      const screenY = ev.clientY - rect.top;
      const world = screenToWorld(screenX, screenY);
      let bestEdge = null;
      let bestDist = Infinity;
      allEdges.forEach((e) => {
        const a = allStations[e.from], b = allStations[e.to];
        const d = pointToSegmentDistance(world.x, world.y, a.x, a.y, b.x, b.y);
        if (d < bestDist) {
          bestDist = d;
          bestEdge = e;
        }
      });
      if (bestEdge && (bestDist * scale) <= 12) {
        bestEdge.active = !bestEdge.active;
        draw();
      }
    });

    canvas.addEventListener("wheel", (ev) => {
      ev.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const screenX = ev.clientX - rect.left;
      const screenY = ev.clientY - rect.top;
      const worldBefore = screenToWorld(screenX, screenY);
      const zoomFactor = 1.1;
      let newScale = (ev.deltaY < 0) ? (scale * zoomFactor) : (scale / zoomFactor);
      newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
      const newX = screenX - worldBefore.x * newScale;
      const newY = screenY - worldBefore.y * newScale;
      scale = newScale;
      defaultX = newX;
      defaultY = newY;
      draw();
    });

    canvas.addEventListener("mousedown", (ev) => {
      nowDrag = true;
      didDrag = false;
      lastX = ev.clientX;
      lastY = ev.clientY;
      canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener("mousemove", (ev) => {
      if (!nowDrag) return;
      ev.preventDefault();
      didDrag = true;
      const dx = ev.clientX - lastX;
      const dy = ev.clientY - lastY;
      defaultX += dx;
      defaultY += dy;
      lastX = ev.clientX;
      lastY = ev.clientY;
      draw();
    });

    canvas.addEventListener("mouseup", (ev) => {
      nowDrag = false;
      canvas.style.cursor = 'pointer';
    });

    canvas.addEventListener("mouseleave", (ev) => {
      nowDrag = false;
      canvas.style.cursor = 'pointer';
    });

    // 保存/読込/全解除
    const STORAGE_KEY = "yamanote_chuo_edges_state_v2"; 
    document.getElementById("saveBtn").onclick = () => {
      const state = allEdges.map(e => e.active ? 1 : 0);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      alert("保存しました。");
    };
    document.getElementById("loadBtn").onclick = () => {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) { alert("保存データがありません。"); return; }
      try {
        const state = JSON.parse(raw);
        if (state.length !== allEdges.length) {
          alert("データ形式が古いため読み込めません。");
          localStorage.removeItem(STORAGE_KEY);
          return;
        }
        allEdges.forEach((e, i) => { e.active = !!state[i]; });
        draw();
        alert("読み込みました。");
      } catch {
        alert("保存データの読み込みに失敗しました。");
      }
    };
    document.getElementById("clearBtn").onclick = () => {
      allEdges.forEach(e => e.active = false);
      draw();
    };
    document.getElementById("resetBtn").onclick = () => {
      scale = 1.0;
      defaultX = 0.0;
      defaultY = 0.0;
      draw();
    };

    // 初回描画
    draw();
  </script>
</body>
</html>